import cv2
import numpy as np


def extract_words_from_projection(image, box, space_threshold):
    rect = cv2.boundingRect(np.array(box)[:, :2].astype(int))
    x, y, w, h = rect
    sub_img = image[y:y + h, x:x + w]

    gray = cv2.cvtColor(sub_img, cv2.COLOR_BGR2GRAY)
    binary = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 11, 2)

    horizontal_projection = np.sum(binary, axis=0)
    spaces = np.where(horizontal_projection == 0)[0]

    words = []
    last_pos = 0

    if len(spaces) > 0:
        for i in range(1, len(spaces)):
            if spaces[i] - spaces[i - 1] > space_threshold:
                words.append((last_pos, spaces[i - 1]))
                last_pos = spaces[i]
        words.append((last_pos, w))  # 添加最后一个单词

    # 处理没有空白的情况
    if not words:
        words.append((0, w))

    word_images = []
    for start, end in words:
        word_img = sub_img[:, start:end]
        word_images.append(word_img)
        cv2.rectangle(sub_img, (start, 0), (end, h), (0, 255, 0), 2)  # 在原图上画出单词边界

    return sub_img, word_images  # 确保总是返回两个值


# 加载图像
image_path = '2.png'
image = cv2.imread(image_path)

# OCR返回的边界框
ocr_boxes = [
    [[165.0, 43.8], [433.8, 42.0], [433.8, 58.8], [165.8, 59.0]],
    [[65.8, 66.8], [216.8, 66.8], [216.8, 83.8], [65.0, 83.8]],
    # 更多边界框...
]

# 设置空白间隔阈值
space_threshold = 20  # 这个阈值可以根据实际情况调整

# 处理每个OCR结果
for box in ocr_boxes:
    processed_image, word_images = extract_words_from_projection(image, box, space_threshold)
    cv2.imshow("Processed Image", processed_image)
    for word_image in word_images:
        cv2.imshow("Word", word_image)
    cv2.waitKey(0)

cv2.destroyAllWindows()
