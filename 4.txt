def calculate_metrics_with_dynamic_tolerance(ocr_results, manual_results, tolerance_ratio=0.2):
    # Convert list of dictionaries to dictionaries for easier access
    ocr_dict = {k: v for d in ocr_results for k, v in d.items()}
    manual_dict = {}
    key_usage_counts = {}  # Dictionary to track how many times each key has been matched

    for d in manual_results:
        for k, v in d.items():
            k = k.strip()
            if k in manual_dict:
                manual_dict[k].append(v)
            else:
                manual_dict[k] = [v]
            key_usage_counts[k] = 0  # Initialize key usage count

    # Variables to hold match details
    true_positive = 0
    false_positive = 0
    false_negative = 0

    # Check each OCR result against the manual results using edit distance for keys with dynamic tolerance
    for ocr_key, ocr_value in list(ocr_dict.items()):
        matched = False
        for manual_key, values in manual_dict.items():
            calculated_tolerance = calculate_dynamic_tolerance(len(manual_key), tolerance_ratio)
            if levenshtein_distance(ocr_key, manual_key) <= calculated_tolerance:
                # Check each value for the current key in manual results
                for i in range(len(values)):
                    if values[i] is not None and key_usage_counts[manual_key] < len(values):  # Ensure key is not overused
                        if ocr_value == values[i]:
                            true_positive += 1
                        else:
                            false_positive += 1
                        values[i] = None  # Mark this value as matched
                        key_usage_counts[manual_key] += 1  # Increment usage count
                        matched = True
                        break
                if matched:
                    break
        if not matched:
            false_positive += 1

    # Remaining unmatched entries in manual_dict are false negatives
    for key, values in manual_dict.items():
        for value in values:
            if value is not None:
                false_negative += 1

    # Calculate precision, recall, and F1 score
    precision = true_positive / (true_positive + false_positive) if (true_positive + false_positive) > 0 else 0
    recall = true_positive / (true_positive + false_negative) if (true_positive + false_negative) > 0 else 0
    f1_score = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0

    return {
        "accuracy": true_positive / (true_positive + false_positive + false_negative) if (
                                                                                                 true_positive + false_positive + false_negative) > 0 else 0,
        "precision": precision,
        "recall": recall,
        "f1_score": f1_score,
        "key_usage_counts": key_usage_counts  # Optionally return usage counts for debugging or further analysis
    }

# 使用这个函数将确保每个manual key的使用不会超过其在数据集中出现的次数。
